import {
  type ChatHistoryItem,
  type ChatStreamEvent,
  type QuickPrompt,
  type SendMessagePayload,
} from '@/entities/chat/types';

const quickPrompts: QuickPrompt[] = [
  {
    id: 'pitch',
    title: 'Craft persuasive email',
    prompt:
      'Write a persuasive email to convince potential customers to try our service.',
    tone: 'Confident',
  },
  {
    id: 'training',
    title: 'Training video outline',
    prompt:
      'Draft a script for a 2-minute training video on how to use our analytics workspace.',
    tone: 'Instructional',
  },
  {
    id: 'demo',
    title: '30s promo script',
    prompt:
      'Create a 30-second commercial script promoting the new product update.',
    tone: 'Promo',
  },
  {
    id: 'explain',
    title: 'Explain AI simply',
    prompt:
      'Explain what our AI agent does in one paragraph with 3 bullet points.',
    tone: 'Simple',
  },
];

const historyItems: ChatHistoryItem[] = [
  // История будет появляться, когда бэкенд вернёт реальные диалоги.
];

export async function fetchMockQuickPrompts(): Promise<QuickPrompt[]> {
  await delay(120);
  return quickPrompts;
}

export async function fetchMockHistory(): Promise<ChatHistoryItem[]> {
  await delay(120);
  return historyItems;
}

const pick = <T>(arr: T[]) => arr[Math.floor(Math.random() * arr.length)];

export async function* mockChatStream(
  payload: SendMessagePayload,
): AsyncGenerator<ChatStreamEvent> {
  const base = [
    'Принял запрос и подключил инструменты: ',
    payload.serverIds.length ? payload.serverIds.join(', ') : 'без MCP',
    '. ',
    'Вот как предлагаю двинуться: ',
  ].join('');

  const steps = [
    'Проверяю контекст в CRM, чтобы понять, кто заказчик.',
    'Запрашиваю свежий прогноз cash-flow через finance.forecast.',
    'Готовлю набор KPI для контроля результата.',
    'Собираю черновик письма для клиента и внутренний чек-лист.',
    largeText,
  ];

  const text = `${base}${pick(
    steps,
  )}. Если нужно — могу дернуть еще /funnel.inspect или /invoice.create.`;
  const parts = text.split(' ');

  for (const part of parts) {
    await new Promise((res) => setTimeout(res, 60));
    yield { type: 'text', delta: `${part} ` };
  }
}

async function delay(ms: number) {
  return new Promise((resolve) => setTimeout(resolve, ms));
}

const largeText = `Когда говорят **«1С»**, обычно имеют в виду программные продукты российской фирмы «1С», предназначенные для автоматизации бизнеса. Это стандарт де-факто в России и многих странах СНГ для ведения бухгалтерского учета, управления торговлей, кадрами и складом.

Чтобы понять суть, нужно разделить понятие на две части: **Платформа** и **Конфигурации**.

### 1. Как это устроено (Принцип «Конструктора»)

Представьте себе игровую приставку и диски с играми.
*   **Платформа «1С:Предприятие»** — это сама «приставка» (движок). Это среда, которая умеет работать с базами данных, интерфейсом и кодом. Сама по себе она пустая.
*   **Конфигурации** — это «игры» (программы), написанные для этой платформы. Именно в них работают пользователи.

### 2. Самые популярные конфигурации

Существует множество готовых решений (конфигураций) для разных задач:

*   **1С:Бухгалтерия** — самая известная программа. Нужна для сдачи отчетности в налоговую, расчета налогов и ведения официального учета. Есть почти в каждой компании.
*   **1С:Управление торговлей (УТ)** — для менеджеров и кладовщиков. Позволяет выписывать счета, следить за остатками на складе, анализировать продажи.
*   **1С:Зарплата и управление персоналом (ЗУП)** — для кадровиков и расчетчиков зарплаты. Больничные, отпуска, наем, увольнение.
*   **1С:ERP** — огромная система для крупных заводов и холдингов. Объединяет всё: закупки, производство, продажи, финансы, ремонты.

### 3. Программирование в 1С

Одна из главных фишек 1С — это **открытый код** конфигураций. Это значит, что любую стандартную программу можно переделать под нужды конкретного бизнеса.

Этим занимаются **программисты 1С**.
*   Язык программирования в 1С — **на русском языке**.
*   Пример кода: Если Сумма > 1000 Тогда Сообщить("Скидка!"); КонецЕсли;
*   Это позволяет быстро вносить изменения в бизнес-логику, не переписывая ядро системы.

### 4. Почему 1С так популярна?

1.  **Законодательство.** В России законы и формы отчетности меняются очень часто. Фирма «1С» выпускает обновления оперативно. Если вы пользуетесь западным софтом (например, SAP), адаптировать его под новые законы РФ долго и дорого.
2.  **Гибкость.** Можно дописать любую кнопку, отчет или функцию под специфику вашего бизнеса (хоть для салона красоты, хоть для автосервиса).
3.  **Доступность специалистов.** Найти бухгалтера, который знает 1С, или программиста, который ее доработает, гораздо проще, чем специалистов по другим системам.

### 5. Откуда взялось название?

Существует легенда (подтвержденная основателем Борисом Нуралиевым), что название **1С** изначально означало **«1 Секунда»**. Идея была в том, что программа для поиска информации должна выдавать ответ не более чем за одну секунду. Позже, когда компания переключилась на бухгалтерский софт, название осталось как бренд.

### Краткий итог

**1С** — это экосистема для бизнеса. Это инструмент, который позволяет директору видеть прибыль, бухгалтеру — сдавать отчеты, а кладовщику — знать, сколько товара осталось на полке.
\`\`\`bsl
// Функция для копирования заказов клиента и переноса товаров
//
// Параметры:
//  ДатаНачала - Дата - Дата начала периода поиска заказов.
//  ДатаОкончания - Дата - Дата окончания периода поиска заказов.
//  Статус - ПеречислениеСсылка.СтатусыЗаказов - Статус, по которому нужно искать заказы.
//
// Возвращаемое значение:
//  Массив - Массив ссылок на созданные заказы (может быть пустым).
//
Функция СкопироватьЗаказыКлиентаИПеренестиТовары(ДатаНачала, ДатаОкончания, Статус) Экспорт

	Результат = Новый Массив;

	// 1. Получаем заказы клиента за указанный период и с указанным статусом.
	Запрос = Новый Запрос;
	Запрос.Текст = 
	"ВЫБРАТЬ
	|	ЗаказКлиента.Ссылка
	|ИЗ
	|	Документ.ЗаказКлиента КАК ЗаказКлиента
	|ГДЕ
	|	ЗаказКлиента.Дата МЕЖДУ &ДатаНачала И &ДатаОкончания
	|	И ЗаказКлиента.Статус = &Статус
	|
	|УПОРЯДОЧИТЬ ПО
	|	ЗаказКлиента.Дата";

	Запрос.УстановитьПараметр("ДатаНачала", ДатаНачала);
	Запрос.УстановитьПараметр("ДатаОкончания", ДатаОкончания);
	Запрос.УстановитьПараметр("Статус", Статус);

	ВыборкаЗаказов = Запрос.Выполнить().Выбрать();

	Пока ВыборкаЗаказов.Следующий() Цикл

		ЗаказКлиентаСсылка = ВыборкаЗаказов.Ссылка;
		ЗаказКлиентаОбъект = ЗаказКлиентаСсылка.ПолучитьОбъект();

		// 2. Создаем новый заказ на основании исходного.
		НовыйЗаказ = Документы.ЗаказКлиента.СоздатьДокумент();

		// Копируем реквизиты шапки.  Важно:  Не копируем ссылку и номер!
		ЗаполнитьЗначенияСвойств(НовыйЗаказ, ЗаказКлиентаОбъект);
		НовыйЗаказ.Дата = ТекущаяДата(); // Устанавливаем текущую дату для нового заказа.
		НовыйЗаказ.Номер = ""; // Очищаем номер, чтобы присвоился автоматически.

		// 3. Переносим строки ТЧ "Товары", у которых статус не "Отгружен".
		Для Каждого СтрокаТовары ИЗ ЗаказКлиентаОбъект.Товары Цикл

			// Проверяем статус строки.  Предполагается, что в ТЧ есть реквизит "СтатусСтроки"
			// и он имеет тип ПеречислениеСсылка.СтатусыСтрокЗаказа (или аналогичный).
			Если СтрокаТовары.СтатусСтроки <> Перечисления.СтатусыСтрокЗаказа.Отгружен Тогда  // Замените на ваш статус

				НоваяСтрокаТовары = НовыйЗаказ.Товары.Добавить();
				ЗаполнитьЗначенияСвойств(НоваяСтрокаТовары, СтрокаТовары);

			КонецЕсли;

		КонецЦикла;

		// 4. Проверяем, что в новый заказ что-то перенесли. Если нет, то не сохраняем.
		Если НовыйЗаказ.Товары.Количество() > 0 Тогда

			Попытка
				НовыйЗаказ.Записать();
				Результат.Добавить(НовыйЗаказ.Ссылка);

				// 5. Меняем статус исходного заказа на "Закрыт".
				ЗаказКлиентаОбъект.Статус = Перечисления.СтатусыЗаказов.Закрыт; // Замените на ваш статус "Закрыт"
				ЗаказКлиентаОбъект.Записать();

			Исключение
				// Обработка ошибок записи нового заказа.
				Сообщить("Ошибка записи нового заказа: " + ОписаниеОшибки());
			КонецПопытки;

		Иначе
			// Если ничего не перенесли, то удаляем созданный заказ.
			// НовыйЗаказ.Удалить(); // Раскомментируйте, если нужно удалять пустые заказы.
			Сообщить("В заказе " + ЗаказКлиентаСсылка + " нет товаров для переноса. Новый заказ не создан.");
		КонецЕсли;

	КонецЦикла;

	Возврат Результат;

КонецФункции
\`\`\`

**Описание кода:**

1. **\`СкопироватьЗаказыКлиентаИПеренестиТовары(ДатаНачала, ДатаОкончания, Статус)\`:**  Функция принимает дату начала, дату окончания и статус заказа в качестве параметров.

2. **\`Результат = Новый Массив;\`:**  Создается массив для хранения ссылок на созданные заказы.

3. **Запрос к базе данных:**
   - Формируется запрос, выбирающий заказы клиента за указанный период и с указанным статусом.
   - Используются параметры запроса для безопасности и читаемости.
   - Заказы упорядочиваются по дате.

4. **Цикл по заказам:**
   - \`ВыборкаЗаказов.Следующий()\`:  Перебирает найденные заказы.
   - \`ЗаказКлиентаСсылка = ВыборкаЗаказов.Ссылка;\`:  Получает ссылку на текущий заказ.
   - \`ЗаказКлиентаОбъект = ЗаказКлиентаСсылка.ПолучитьОбъект();\`:  Получает объект заказа для работы с данными.

5. **Создание нового заказа:**
   - \`НовыйЗаказ = Документы.ЗаказКлиента.СоздатьДокумент();\`:  Создает новый документ "ЗаказКлиента".
   - \`ЗаполнитьЗначенияСвойств(НовыйЗаказ, ЗаказКлиентаОбъект);\`:  Копирует все реквизиты шапки из исходного заказа в новый.  **Важно:**  Не копируются ссылка и номер, так как они должны быть уникальными для каждого документа.
   - \`НовыйЗаказ.Дата = ТекущаяДата();\`: Устанавливает текущую дату для нового заказа.
   - \`НовыйЗаказ.Номер = "";\`: Очищает номер, чтобы платформа присвоила его автоматически при записи.

6. **Перенос строк ТЧ "Товары":**
   - \`Для Каждого СтрокаТовары ИЗ ЗаказКлиентаОбъект.Товары Цикл\`:  Перебирает строки табличной части "Товары" исходного заказа.
   - \`Если СтрокаТовары.СтатусСтроки <> Перечисления.СтатусыСтрокЗаказа.Отгружен Тогда\`:  Проверяет статус строки.  **Важно:**  Замените \`СтрокаТовары.СтатусСтроки\` и \`Перечисления.СтатусыСтрокЗаказа.Отгружен\` на ваши фактические реквизиты и значения.
   - \`НоваяСтрокаТовары = НовыйЗаказ.Товары.Добавить();\`:  Добавляет новую строку в ТЧ "Товары" нового заказа.
   - \`ЗаполнитьЗначенияСвойств(НоваяСтрокаТовары, СтрокаТовары);\`:  Копирует все реквизиты строки товара из исходного заказа в новый.

7. **Проверка и запись нового заказа:**
   - \`Если НовыйЗаказ.Товары.Количество() > 0 Тогда\`:  Проверяет, что в новый заказ были перенесены товары.
   - \`НовыйЗаказ.Записать();\`:  Записывает новый заказ в базу данных.
   - \`Результат.Добавить(НовыйЗаказ.Ссылка);\`:  Добавляет ссылку на новый заказ в массив результатов.
   - Обработчик исключений \`Попытка...Исключение\` для обработки возможных ошибок при записи.

8. **Изменение статуса исходного заказа:**
   - \`ЗаказКлиентаОбъект.Статус = Перечисления.СтатусыЗаказов.Закрыт;\`:  Меняет статус исходного заказа на "Закрыт".  **Важно:**  Замените \`Перечисления.СтатусыЗаказов.Закрыт\` на ваш фактический статус.
   - \`ЗаказКлиентаОбъект.Записать();\`:  Записывает изменения в исходный заказ.

9. **Обработка пустых заказов:**
   - Если в новый заказ не было перенесено ни одной строки, то он не записывается.  Можно раскомментировать строку \`// НовыйЗаказ.Удалить();\` для удаления таких заказов.

10. **Возврат результата:**
    - \`Возврат Результат;\`:  Возвращает массив ссылок на созданные заказы.

**Как использовать:**

\`\`\`bsl
ДатаНачала = Дата(2023, 01, 01);
ДатаОкончания = Дата(2023, 12, 31);
СтатусЗаказа = Перечисления.СтатусыЗаказов.Согласован; // Замените на ваш статус

СозданныеЗаказы = СкопироватьЗаказыКлиентаИПеренестиТовары(ДатаНачала, ДатаОкончания, СтатусЗаказа);

Если СозданныеЗаказы.Количество() > 0 Тогда
	Сообщить("Создано заказов: " + СозданныеЗаказы.Количество());
	Для Каждого ЗаказСсылка ИЗ СозданныеЗаказы Цикл
		Сообщить("  - " + ЗаказСсылка);
	КонецЦикла;
Иначе
	Сообщить("Не найдено заказов для копирования.");
КонецЕсли;
\`\`\`

**Важные замечания:**

* **Замените плейсхолдеры:**  Обязательно замените \`Перечисления.СтатусыЗаказов.Согласован\`, \`Перечисления.СтатусыЗаказов.Закрыт\`, \`СтрокаТовары.СтатусСтроки\` и \`Перечисления.СтатусыСтрокЗаказа.Отгружен\` на ваши фактические значения и реквизиты в конфигурации.
* **Права доступа:** Убедитесь, что у пользователя, выполняющего код, есть права на чтение заказов, создание новых заказов и изменение статуса существующих заказов.
* **Транзакции:**  Для обеспечения целостности данных рекомендуется обернуть код в транзакцию.  В случае ошибки записи одного из заказов, все изменения будут отменены.
* **Тестирование:**  Перед использованием кода в рабочей базе данных тщательно протестируйте его на тестовой базе.
* **Реквизиты шапки:**  Убедитесь, что все необходимые реквизиты шапки заказа копируются корректно.  Возможно, потребуется добавить дополнительную логику для обработки специфических реквизитов.
* **Статус строки:**  Убедитесь, что реквизит \`СтатусСтроки\` в ТЧ "Товары" существует и имеет правильный тип.
* **Производительность:**  Для большого количества заказов может потребоваться оптимизация запроса и кода.  Рассмотрите возможность использования пакетной записи документов.
* **Блокировки:** При массовом изменении статусов заказов, необходимо учитывать возможные блокировки базы данных.  Рекомендуется выполнять операцию в нерабочее время или использовать механизмы управления блокировками.

Этот код предоставляет базовую функциональность.  Вам может потребоваться адаптировать его под конкретные требования вашей конфигурации.
`;
